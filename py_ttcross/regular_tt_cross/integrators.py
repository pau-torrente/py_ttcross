from types import FunctionType
import numpy as np
from numpy.polynomial.legendre import leggauss
from .dmrg_cross import greedy_cross, ttrc
from abc import ABC, abstractmethod
from ncon import ncon


class tt_integrator(ABC):
    """Base class for the tt-cross-based integrators. It contains the common methods to generate the grids and
    quadrature vectors, as well as the method to contract the tt-cross interpolation of the function generated by
    the child classes with these quadrature weights.

    Args:
        - func (FunctionType): The function to be integrated. Should take a numpy vector as an input and return a float
        or a complex number. For speed purposes, it is highly recommended to pass a function which can be numba jit
        compiled.

        - num_variables (int): The number of variables of the function to be integrated.

        - intervals (np.ndarray): The intervals of integration for each variable. It should be a numpy array of shape
        (num_variables, 2), where the first column contains the lower bounds and the second column contains the upper
        bounds.

        - points_per_variable (int | list[int]): The number of points to be used in the quadrature for each variable. If
        an integer is passed, the same number of points will be used for all variables. If a list of integers is passed,
        the length of the list must be equal to num_variables.

        - sweeps (int): The number of sweeps to be performed by the tt-cross algorithm.

        - is_f_complex (bool): Whether the function to be integrated returns complex numbers or not. Defauls to False.

        - quadrature (str): The quadrature method to be used. Can be "Simpson", "Trapezoidal" or "Gauss". Defaults to
        "Trapezoidal".

        - pivot_initialization (str): The method to be used to initialize the pivot sets in the tt-cross algorithm. Can
        be "random" or "first_n". Defaults to "random".
    """

    def __init__(
        self,
        func: FunctionType,
        num_variables: int,
        intervals: np.ndarray,
        points_per_variable: int | list[int],
        sweeps: int,
        is_f_complex: bool = False,
        quadrature: str = "Trapezoidal",
        pivot_initialization: str = "random",
    ) -> None:

        self.func = func
        self.num_variables = num_variables

        if len(intervals) != num_variables and all(interval.shape != (2,) for interval in intervals):
            raise ValueError("Invalid intervals")
        self.intervals = intervals

        if isinstance(points_per_variable, int):
            self.points_per_variable = [points_per_variable] * num_variables
        elif len(points_per_variable) != num_variables:
            raise ValueError("Length of the points_per_variable list must be equal to num_variables")
        else:
            self.points_per_variable = points_per_variable

        self.sweeps = sweeps
        self.is_f_complex = is_f_complex

        if quadrature not in ["Simpson", "Trapezoidal", "Gauss"]:
            raise ValueError("Invalid quadrature method")

        self.quadrature = quadrature
        self.weights = np.ndarray(self.num_variables, dtype=object)
        self.grid = np.ndarray(self.num_variables, dtype=object)
        self._initialize_grid_and_weights()
        self.pivot_init = pivot_initialization

    def _initialize_grid_and_weights(self):
        """Helper method that initializes the grid and weights for the quadrature method specified in the constructor.

        Raises:
            NotImplementedError: If the given quadrature rule is not implemented.
        """
        match self.quadrature:
            case "Simpson":
                self.grid = np.array(
                    [
                        np.linspace(self.intervals[i][0], self.intervals[i][1], self.points_per_variable[i])
                        for i in range(self.num_variables)
                    ]
                )

                self._create_simpson_weights()

            case "Trapezoidal":
                self.grid = np.array(
                    [
                        np.linspace(self.intervals[i][0], self.intervals[i][1], self.points_per_variable[i])
                        for i in range(self.num_variables)
                    ]
                )

                self._create_trapezoidal_weights()

            case "Gauss":
                for i in range(self.num_variables):
                    b = self.intervals[i][1]
                    a = self.intervals[i][0]
                    points, weights = leggauss(self.points_per_variable[i])
                    self.grid[i] = 0.5 * (b - a) * points + 0.5 * (b + a)
                    self.weights[i] = 0.5 * (b - a) * weights

            case _:
                raise NotImplementedError("This quadrature method is not implemented")

    def _create_trapezoidal_weights(self):
        """Helper method to create the weights for the trapezoidal quadrature rule."""
        for k in range(self.num_variables):
            h = self.grid[k][1] - self.grid[k][0]
            self.weights[k] = np.zeros(self.points_per_variable[k])
            self.weights[k][0] = 1
            self.weights[k][-1] = 1
            self.weights[k][1:-1] = 2
            self.weights[k] *= h / 2

    def _create_simpson_weights(self):
        """Helper method to create the weights for the Simpson quadrature rule.

        Raises:
            ValueError: If the number of points per variable is even, which is not allowed for Simpson quadrature.
        """
        for k in range(self.num_variables):
            if self.points_per_variable[k] % 2 == 0:
                raise ValueError(
                    f"Number of points per variable must be odd for Simpson quadrature. In the variable {k} it is {self.points_per_variable[k]}"
                )

            h = self.grid[k][1] - self.grid[k][0]

            self.weights[k] = np.zeros(self.points_per_variable[k])
            self.weights[k][0] = 1
            self.weights[k][-1] = 1

            if self.points_per_variable[k] > 3:
                self.weights[k][1:-1:2] = 4
                self.weights[k][2:-1:2] = 2
            else:
                self.weights[k][1] = 4

            self.weights[k] *= h / 3

    @abstractmethod
    def _interpolate(self):
        """Method that calls the desired interpolator."""

    def integrate(self) -> float | complex:
        """Method to integrate the function using the quadrature method specified in the constructor.

        Returns:
            float | complex: The value of the integral of the function.
        """
        tensor_train = self._interpolate()

        result = ncon(
            [self.weights[0], tensor_train[0][0]],
            [[1], [1, -1]],
        )

        for i in range(1, self.num_variables):
            result = ncon(
                [result, tensor_train[2 * i - 1]],
                [[1], [1, -1]],
            )

            result = ncon([result, tensor_train[2 * i]], [[1], [1, -1, -2]])

            result = ncon(
                [self.weights[i], result],
                [[1], [1, -1]],
            )

        return result[0]


class ttrc_integrator(tt_integrator):
    """Class that implements the tt-cross-based integrator using the ttrc algorithm.

    Args:
        - func (FunctionType): The function to be integrated. Should take a numpy vector as an input and return a float
        or a complex number. For speed purposes, it is highly recommended to pass a function which can be numba jit
        compiled.

        - num_variables (int): The number of variables of the function to be integrated.

        - intervals (np.ndarray): The intervals of integration for each variable. It should be a numpy array of shape
        (num_variables, 2), where the first column contains the lower bounds and the second column contains the upper
        bounds.

        - points_per_variable (int | list[int]): The number of points to be used in the quadrature for each variable. If
        an integer is passed, the same number of points will be used for all variables. If a list of integers is passed,
        the length of the list must be equal to num_variables.

        - sweeps (int): The number of sweeps to be performed by the tt-cross algorithm.

        - initial_bond_guess (int): The initial number of pivots to be used in the ttrc algorithm as an initial crude
        approximation

        - max_bond (int): The maximum number of pivots allowed at each cross block in the ttrc algorithm.

        - maxvol_tol (float): The tolerance to be used in the pivot finding procedure of the maxvol algorithm.
        Defaults to 1e-4.

        - truncation_tol (float): The tolerance to be used in the truncation process of the ttrc algorithm after
        performing the SVD on the 2-site blocks. Defaults to 1e-10.

        - is_f_complex (bool): Whether the function to be integrated returns complex numbers or not. Defauls to False.

        - quadrature (str): The quadrature method to be used. Can be "Simpson", "Trapezoidal" or "Gauss". Defaults to
        "Trapezoidal".

        - pivot_initialization (str): The method to be used to initialize the pivot sets in the tt-cross algorithm. Can
        be "random" or "first_n". Defaults to "random".
    """

    def __init__(
        self,
        func: FunctionType,
        num_variables: int,
        intervals: np.ndarray,
        points_per_variable: int | list[int],
        sweeps: int,
        initial_bond_guess: int,
        max_bond: int,
        maxvol_tol: float = 1e-4,
        truncation_tol: float = 1e-10,
        is_f_complex: bool = False,
        quadrature: str = "Trapezoidal",
        pivot_initialization: str = "random",
    ) -> None:

        super().__init__(
            func,
            num_variables,
            intervals,
            points_per_variable,
            sweeps,
            is_f_complex,
            quadrature,
        )

        self.maxvol_tol = maxvol_tol
        self.truncation_tol = truncation_tol
        self.init_bond = initial_bond_guess
        self.maxbond = max_bond
        self.pivot_init = pivot_initialization

    def _interpolate(self) -> np.ndarray:
        """Method that calls the ttrc interpolator to generate the tensor train interpolation for the integral
        computation.

        Returns:
            np.ndarray: The tensor train containing the tt-cross interpolation of the function.
        """
        self.interpolator = ttrc(
            func=self.func,
            num_variables=self.num_variables,
            grid=self.grid,
            maxvol_tol=self.maxvol_tol,
            truncation_tol=self.truncation_tol,
            sweeps=self.sweeps,
            initial_bond_guess=self.init_bond,
            max_bond=self.maxbond,
            is_f_complex=self.is_f_complex,
            pivot_initialization=self.pivot_init,
        )

        self.interpolation = self.interpolator.run()
        return self.interpolation


class greedy_cross_integrator(tt_integrator):
    """Class that implements the tt-cross-based integrator using the greedy-cross algorithm.

    Args:
        - func (FunctionType): The function to be integrated. Should take a numpy vector as an input and return a float
        or a complex number. For speed purposes, it is highly recommended to pass a function which can be numba jit
        compiled.

        - num_variables (int): The number of variables of the function to be integrated.

        - intervals (np.ndarray): The intervals of integration for each variable. It should be a numpy array of shape
        (num_variables, 2), where the first column contains the lower bounds and the second column contains the upper
        bounds.

        - points_per_variable (int | list[int]): The number of points to be used in the quadrature for each variable. If
        an integer is passed, the same number of points will be used for all variables. If a list of integers is passed,
        the length of the list must be equal to num_variables.

        - sweeps (int): The number of sweeps to be performed by the tt-cross algorithm.

        - initial_bond_guess (int): The initial number of pivots to be used in the ttrc algorithm as an initial crude
        approximation

        - max_bond (int): The maximum number of pivots allowed at each cross block in the ttrc algorithm.

        - pivot_finder_tol (float): The tolerance to be used in the pivot finding procedure. Defaults to 1e-10.

        - is_f_complex (bool): Whether the function to be integrated returns complex numbers or not. Defauls to False.

        - quadrature (str): The quadrature method to be used. Can be "Simpson", "Trapezoidal" or "Gauss". Defaults to
        "Trapezoidal".

        - pivot_initialization (str): The method to be used to initialize the pivot sets in the tt-cross algorithm. Can
        be "random" or "first_n". Defaults to "random".
    """

    def __init__(
        self,
        func: FunctionType,
        num_variables: int,
        intervals: np.ndarray,
        points_per_variable: int | list[int],
        sweeps: int,
        max_bond: int,
        pivot_finder_tol: float = 1e-10,
        is_f_complex: bool = False,
        quadrature: str = "Trapezoidal",
    ) -> None:

        super().__init__(
            func,
            num_variables,
            intervals,
            points_per_variable,
            sweeps,
            is_f_complex,
            quadrature,
        )

        self.tol = pivot_finder_tol
        self.maxbond = max_bond

    def _interpolate(self):
        """Method that calls the greedy cross interpolator to generate the tensor train interpolation for the integral
        computation.

        Returns:
            np.ndarray: The tensor train containing the tt-cross interpolation of the function.
        """
        self.interpolator = greedy_cross(
            func=self.func,
            num_variables=self.num_variables,
            grid=self.grid,
            tol=self.tol,
            max_bond=self.maxbond,
            sweeps=self.sweeps,
            is_f_complex=self.is_f_complex,
        )

        self.interpolation = self.interpolator.run()
        return self.interpolation


class tracked_ttrc_integrator(ttrc, tt_integrator):
    """Variant of the ttrc integrator that keeps track of the evolution of the integral value after each sweep.
    Beware that by doing this, the integrator will have to ignore indices to compute the integrals after each sweep
    if the algorithm has not converged yet and the pivot sets are not of the same size. This does not discard the
    indices themselves, which are kept for the following steps, but they are just not used.

    Args:
        - func (FunctionType): The function to be integrated. Should take a numpy vector as an input and return a float
        or a complex number. For speed purposes, it is highly recommended to pass a function which can be numba jit
        compiled.

        - num_variables (int): The number of variables of the function to be integrated.

        - intervals (np.ndarray): The intervals of integration for each variable. It should be a numpy array of shape
        (num_variables, 2), where the first column contains the lower bounds and the second column contains the upper
        bounds.

        - points_per_variable (int | list[int]): The number of points to be used in the quadrature for each variable. If
        an integer is passed, the same number of points will be used for all variables. If a list of integers is passed,
        the length of the list must be equal to num_variables.

        - sweeps (int): The number of sweeps to be performed by the tt-cross algorithm.

        - initial_bond_guess (int): The initial number of pivots to be used in the ttrc algorithm as an initial crude
        approximation

        - max_bond (int): The maximum number of pivots allowed at each cross block in the ttrc algorithm.

        - maxvol_tol (float): The tolerance to be used in the pivot finding procedure of the maxvol algorithm.
        Defaults to 1e-4.

        - truncation_tol (float): The tolerance to be used in the truncation process of the ttrc algorithm after
        performing the SVD on the 2-site blocks. Defaults to 1e-10.

        - is_f_complex (bool): Whether the function to be integrated returns complex numbers or not. Defauls to False.

        - quadrature (str): The quadrature method to be used. Can be "Simpson", "Trapezoidal" or "Gauss". Defaults to
        "Trapezoidal".

        - pivot_initialization (str): The method to be used to initialize the pivot sets in the tt-cross algorithm. Can
        be "random" or "first_n". Defaults to "random".
    """

    def __init__(
        self,
        func: FunctionType,
        num_variables: int,
        intervals: np.ndarray,
        points_per_variable: int | list[int],
        sweeps: int,
        initial_bond_guess: int,
        max_bond: int,
        maxvol_tol: float = 1e-4,
        truncation_tol: float = 1e-10,
        is_f_complex: bool = False,
        quadrature: str = "Trapezoidal",
    ) -> None:

        self.func = func
        self.num_variables = num_variables

        if len(intervals) != num_variables and all(interval.shape != (2,) for interval in intervals):
            raise ValueError("Invalid intervals")
        self.intervals = intervals

        if isinstance(points_per_variable, int):
            self.points_per_variable = [points_per_variable] * num_variables
        elif len(points_per_variable) != num_variables:
            raise ValueError("Length of the points_per_variable list must be equal to num_variables")
        else:
            self.points_per_variable = points_per_variable

        self.sweeps = sweeps
        self.is_f_complex = is_f_complex

        if quadrature not in ["Simpson", "Trapezoidal", "Gauss"]:
            raise ValueError("Invalid quadrature method")

        self.quadrature = quadrature
        self.weights = np.ndarray(self.num_variables, dtype=object)
        self.grid = np.ndarray(self.num_variables, dtype=object)
        self._initialize_grid_and_weights()
        self.func_calls = 0
        self.evolution = []

        super().__init__(
            func=func,
            num_variables=num_variables,
            grid=self.grid,
            maxvol_tol=maxvol_tol,
            truncation_tol=truncation_tol,
            sweeps=sweeps,
            initial_bond_guess=initial_bond_guess,
            max_bond=max_bond,
            is_f_complex=is_f_complex,
        )

    def full_sweep(self) -> None:
        """Method that overrides the full_sweep method of the ttrc algorithm to keep track of the evolution of the
        integral value after each sweep. The call to the check_index_sets makes sure that the index sets I_k and J_k
        are of the same size, which is necessary to compute the tt-cross approximation after each sweep. Once the
        integral has been computed, the indices are restored to their original values.
        """
        super().full_sweep()

        mps = np.ndarray(2 * self.num_variables - 1, dtype=np.ndarray)

        self.check_index_sets()

        for site in range(self.num_variables - 1):
            mps[2 * site] = self.compute_single_site_tensor(site)
            mps[2 * site + 1] = self.compute_cross_blocks(site)

        mps[-1] = self.compute_single_site_tensor(self.num_variables - 1)

        result = ncon(
            [self.weights[0], mps[0][0]],
            [[1], [1, -1]],
        )

        for i in range(1, self.num_variables):
            result = ncon(
                [result, mps[2 * i - 1]],
                [[1], [1, -1]],
            )

            result = ncon([result, mps[2 * i]], [[1], [1, -1, -2]])

            result = ncon(
                [self.weights[i], result],
                [[1], [1, -1]],
            )

        self.evolution.append([self.func_calls, result[0]])

        self.i = self.non_truncated_i
        self.j = self.non_truncated_j

    def _interpolate(self):
        """Method to call the ttrc algorithm .run() method and generate the tt-cross approximation of the function.

        Returns:
            np.ndarray: The tensor train containing the tt-cross interpolation of the function.
        """
        return self.run()


class tracked_greedycross_integrator(greedy_cross, tt_integrator):
    """Variant of the Greedy-Cross based integrator that computed the intgeral after each index update to keep track of
    evolution and convergence of the algorithm.

    Args:
        - func (FunctionType): The function to be integrated. Should take a numpy vector as an input and return a float
        or a complex number. For speed purposes, it is highly recommended to pass a function which can be numba jit
        compiled.

        - num_variables (int): The number of variables of the function to be integrated.

        - intervals (np.ndarray): The intervals of integration for each variable. It should be a numpy array of shape
        (num_variables, 2), where the first column contains the lower bounds and the second column contains the upper
        bounds.

        - points_per_variable (int | list[int]): The number of points to be used in the quadrature for each variable. If
        an integer is passed, the same number of points will be used for all variables. If a list of integers is passed,
        the length of the list must be equal to num_variables.

        - sweeps (int): The number of sweeps to be performed by the tt-cross algorithm.

        - initial_bond_guess (int): The initial number of pivots to be used in the ttrc algorithm as an initial crude
        approximation

        - max_bond (int): The maximum number of pivots allowed at each cross block in the ttrc algorithm.

        - pivot_finder_tol (float): The tolerance to be used in the pivot finding procedure. Defaults to 1e-10.

        - is_f_complex (bool): Whether the function to be integrated returns complex numbers or not. Defauls to False.

        - quadrature (str): The quadrature method to be used. Can be "Simpson", "Trapezoidal" or "Gauss". Defaults to
        "Trapezoidal".

        - pivot_initialization (str): The method to be used to initialize the pivot sets in the tt-cross algorithm. Can
        be "random" or "first_n". Defaults to "random".
    """

    def __init__(
        self,
        func: FunctionType,
        num_variables: int,
        intervals: np.ndarray,
        points_per_variable: int | list[int],
        sweeps: int,
        max_bond: int,
        pivot_finder_tol: float = 1e-10,
        is_f_complex: bool = False,
        quadrature: str = "Trapezoidal",
    ) -> None:

        self.func = func
        self.num_variables = num_variables

        if len(intervals) != num_variables and all(interval.shape != (2,) for interval in intervals):
            raise ValueError("Invalid intervals")
        self.intervals = intervals

        if isinstance(points_per_variable, int):
            self.points_per_variable = [points_per_variable] * num_variables
        elif len(points_per_variable) != num_variables:
            raise ValueError("Length of the points_per_variable list must be equal to num_variables")
        else:
            self.points_per_variable = points_per_variable

        self.sweeps = sweeps
        self.is_f_complex = is_f_complex

        if quadrature not in ["Simpson", "Trapezoidal", "Gauss"]:
            raise ValueError("Invalid quadrature method")

        self.quadrature = quadrature
        self.weights = np.ndarray(self.num_variables, dtype=object)
        self.grid = np.ndarray(self.num_variables, dtype=object)
        self._initialize_grid_and_weights()
        self.func_calls = 0
        self.evolution = []

        super().__init__(
            func=func,
            num_variables=num_variables,
            grid=self.grid,
            tol=pivot_finder_tol,
            max_bond=max_bond,
            sweeps=sweeps,
            is_f_complex=is_f_complex,
        )

    def index_update(self, site: int):
        """Method that overrides the index_update method of the greedy-cross algorithm to keep track of the evolution of
        the integral value after each index update. Beware that this procedure makes the algorithm much slower,
        obviously, as it has to compute the integral after each index update. If the evolution is not needed, it is
        recommended to use the regular greedy-cross integrator.

        Args:
            site (int): The site at which the index update is being performed.
        """
        super().index_update(site)

        mps = np.ndarray(2 * self.num_variables - 1, dtype=np.ndarray)

        for site in range(self.num_variables - 1):
            mps[2 * site] = self.compute_single_site_tensor(site)
            mps[2 * site + 1] = self.compute_cross_blocks(site)

        mps[-1] = self.compute_single_site_tensor(self.num_variables - 1)

        result = ncon(
            [self.weights[0], mps[0][0]],
            [[1], [1, -1]],
        )

        for i in range(1, self.num_variables):
            result = ncon(
                [result, mps[2 * i - 1]],
                [[1], [1, -1]],
            )

            result = ncon([result, mps[2 * i]], [[1], [1, -1, -2]])

            result = ncon(
                [self.weights[i], result],
                [[1], [1, -1]],
            )

        self.evolution.append([self.func_calls, result[0]])

    def _interpolate(self):
        """Method to call the greedy-cross algorithm .run() method and generate the tt-cross approximation of the
        function.

        Returns:
            np.ndarray: The tensor train containing the tt-cross interpolation of the function.
        """
        return self.run()
